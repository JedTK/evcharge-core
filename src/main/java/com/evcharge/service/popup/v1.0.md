# 弹窗中台（Popup Center）设计方案 v1

> 目标：前端只问「现在该弹什么？」，后端统一回答「弹不弹、弹哪个、弹什么内容、弹给谁、弹几次」。

---

## 一、背景与目标

### 1.1 现状

当前各类弹窗逻辑分散在不同业务接口中，例如：

* 圣诞活动弹窗：调用「圣诞活动」专用 API。
* 公告弹窗：调用「公告列表 / 公告详情」API。
* 中奖提醒弹窗：调用「中奖 / 抽奖」相关 API。
* 版本更新、强制协议弹窗：各自有独立的接口与逻辑。

特征是：**每一种弹窗都有自己的一套判断规则和接口**，导致：

1. 前端需要维护多套调用逻辑，增加开发成本和出错概率。
2. 弹窗优先级、展示频率、互斥规则无法统一，只能在各业务里“各写一遍”。
3. 新增一种弹窗时，需要前后端各自改一轮，扩展成本高。
4. 难以从整体视角控制用户的弹窗体验，容易出现多弹、乱弹、频繁打扰。

### 1.2 核心痛点

* **调用不统一**：前端不知道该调哪个接口，只能一个个业务接口轮询判断。
* **逻辑不统一**：不同弹窗的“是否弹”、“多久弹一次”、“看过还弹不弹”在各处重复开发。
* **策略难以集中控制**：无法全局限制某段时间、某场景中用户被弹的总次数，也无法统一优先级。
* **运营弱依赖开发**：活动弹窗、版本弹窗、公告弹窗等没有统一管理后台，运营每次需求都要找开发改代码上线。

### 1.3 建设目标

通过建设「弹窗中台 + 统一判断 API」，实现：

1. **统一调用入口**
    * 前端只调用一个接口：`/api/popup/check`。
    * 由后端统一判断：
        * 当前要不要弹？
        * 弹哪个弹窗？
        * 弹几个？以什么顺序？

2. **配置化内容与策略**
    * 弹窗内容（标题、文案、图片、按钮、跳转）由后台统一配置，避免频繁改代码。
    * 支持按组织、平台、客户端版本、人群等维度配置。

3. **统一频率、人群、优先级控制**
    * 防骚扰：控制每用户每天/活动期展示次数。
    * 精准触达：按用户 ID / 标签 / 新老用户 / 渠道等做定向。
    * 冲突处理：当多种弹窗同时满足条件时，统一按优先级与规则决策。

4. **事件 + 模板驱动**
    * 业务只需要执行“一句代码”：
        * 指定 `popupCode`（或 `templateCode`）
        * 传入少量参数（如中奖金额、奖品名、特定用户 ID 等）
    * 文案与排版全部由模板和运营配置解决，业务不关心文案细节。

5. **统一埋点与数据闭环**
    * 统一上报弹窗曝光、点击、关闭、完成等行为。
    * 支撑频控与统计，形成可评估、可优化的运营闭环。

一句话总结：
**前端只负责问：现在应该弹什么？
后端给出：弹或不弹 + 具体内容 + 展示策略。
业务侧只需要知道：要触发哪个弹窗（popupCode）+ 模板参数。**

---

## 二、业务范围与弹窗类型

弹窗中台统一管理的弹窗类型包括但不限于：

1. **活动类弹窗**
    * 节日活动：圣诞、春节等。
    * 充值送券、满减活动、拉新活动、邀请奖励等。

2. **系统公告类弹窗**
    * 系统维护公告。
    * 新功能上线公告。
    * 停服/迁移/重要通知等。

3. **订单 / 结果类弹窗**
    * 中奖提醒、抽奖结果弹窗。
    * 优惠券到账提醒。
    * 订单异常、订单结果提示等。

4. **版本控制类弹窗**
    * 新版本更新提示。
    * 强制更新（不更新无法继续使用）。

5. **协议类弹窗**
    * 隐私政策更新。
    * 用户协议更新。
    * 强制阅读并勾选的合规弹窗。

6. **扩展弹窗**
    * 某些特定场景的运营或风控提示弹窗。
    * AB 实验弹窗等。

未来新增弹窗类型，只要定义好配置字段与判断规则即可接入，无需改变前端调用方式。

---

## 三、核心设计原则

1. **单一入口，统一决策**
    * 所有弹窗统一通过 `/api/popup/check` 返回，由后端完成决策。

2. **配置驱动 + 模板驱动**
    * 配置层控制“何时弹、给谁弹、弹哪个类型”。
    * 模板层控制“弹什么内容、用哪些变量填充”。

3. **业务与文案彻底解耦**
    * 业务逻辑只认 `popupCode / templateCode` 和参数，不参与文案拼接。
    * 文案由运营在模板中配置，通过占位符使用业务参数。

4. **事件驱动弹窗（可选）**
    * 对于结果类弹窗（例如中奖弹窗），以“业务事件 → 待弹记录 → 用户下次 /check 时拉取”的方式实现。

5. **优先考虑用户体验**
    * 保证不会出现“乱弹”“狂弹”情况。
    * 强制弹窗仅限协议、版本等少数场景，且可严格审核配置。

---

## 四、核心数据模型与概念

### 4.1 PopupConfig：弹窗配置（规则 + 静态内容）

用于定义一个弹窗“长什么样 + 什么时候弹 + 给谁弹 + 限制多少次”等信息。

主要字段示意（逻辑层面）：

* 基础信息：
    * `id`
    * `organize_code`：组织代码
    * `platform_code`：平台代码（如元气充、某品牌等）
    * `popup_code`：弹窗编码，业务与中台统一使用的唯一标识
    * `name`：弹窗名称（例如“2025圣诞活动弹窗”）
    * `popup_type`：弹窗类型（activity / notice / lottery / version / protocol 等）

* 展示内容（静态模式下直接使用，模板模式下作为兜底）：
    * `title`
    * `subtitle`
    * `content`（可支持简单富文本）
    * `image_url`
    * `main_button_text` / `main_button_action_type` / `main_button_action_value`
    * `secondary_button_text` / `secondary_button_action_type` / `secondary_button_action_value`
    * `show_close_button` / `close_button_text`
    * 展示风格信息：`theme`、`layout`、`mask` 等（可选）

* 时间与有效期：
    * `start_time`、`end_time`
    * 可选：`daily_start_time`、`daily_end_time`（每天的展示时间段）

* 目标人群 / 场景：
    * `scene_codes`：适用场景列表（app_launch / home_enter / order_finish / activity_center等）
    * `client_codes`：适用客户端列表（MiniProgram / H5 / Android / iOS / Admin 等）
    * `target_user_scope`：全量用户 / 仅登录用户 / 新用户 / 老用户等
    * `target_user_ids`：指定用户列表（可选）
    * `target_tags`：用户标签（JSON）

* 版本与渠道：
    * `min_app_version`、`max_app_version`
    * `channel_codes`：渠道（如微信、支付宝、独立 App 等）

* 频率控制：
    * `enable_freq_limit`：是否启用频控
    * `user_daily_limit`：单用户单日展示上限
    * `user_total_limit`：单用户整个活动期展示上限
    * `global_daily_limit`：全局单日展示上限（防止配置错误刷量）
    * `seen_no_longer_show`：曝光一次后不再展示
    * `clicked_no_longer_show`：点击主按钮后不再展示
    * `closed_no_longer_show`：关闭后不再展示

* 优先级与冲突处理：
    * `priority`：优先级数值（约定数值越小优先级越高，或反之，统一即可）
    * `level`：等级（紧急/重要/普通）
    * `allow_multi_popup`：是否允许与其他弹窗共同展示（返回多个让前端依次弹出）

* 其他：
    * `force_flag`：是否强制弹窗（不处理无法继续）
    * `delay_seconds`：延迟多少秒后弹出
    * `experiment_group` / `gray_percent`：AB / 灰度相关字段
    * `status`：启用/停用
    * `remark`、`create_time`、`update_time` 等审计字段

### 4.2 PopupTemplate：弹窗内容模板（带占位符）

用于定义含变量的弹窗内容模板，让业务只需传参，不关心文案细节。

主要字段示意：

* `id`

* `organize_code`

* `template_code`：模板编码，业务侧可直接认这个

* `popup_code`：关联的弹窗编码（一个弹窗可对应一个主模板）

* `channel`：渠道（目前主要是 `popup`，未来可扩展 `sms`、`message` 等）

* `lang`：语言（zh-CN / en-US 等）

* 内容模板：
    * `title_template`：标题模板，如 `恭喜你获得 {{prize_name}}`
    * `content_template`：正文模板，包含占位符，如：
        * `您在活动「{{activity_name}}」中中奖，获得 {{prize_name}}，奖励金额 {{amount}} 元。`
    * `button_main_template`：主按钮文案模板（可用变量）
    * `button_sub_template`：副按钮文案模板（可用变量）

* 参数元信息：
    * `params_meta`：JSON，描述模板需要哪些变量、类型、是否必填等，方便后台做校验与提示

* 状态与审计：
    * `status`：启用/停用
    * `remark`、`create_time`、`update_time`

**占位符约定**：建议格式为 `{{param_name}}`，实现简单，不依赖复杂模板引擎。

### 4.3 PopupPending：待弹窗事件记录（业务事件 → 待弹记录）

用于记录业务触发的“待展示弹窗”，适用于中奖、到账等结果类弹窗：

* `id`
* `uid`：用户 ID
* `popup_code`：弹窗编码
* `scene_code`：建议弹出的场景（可选，例如希望在 home_enter 时弹）
* `params_json`：模板参数 JSON（例如中奖金额、奖品名、活动名等）
* `status`：
    * 0 = 待展示
    * 1 = 已拉取
    * 2 = 失效/已完成/已废弃（按实际定义）
* `expire_time`：记录过期时间（过期后即便未展示也不再弹）
* `create_time`、`update_time`

业务调用触发接口时，只需要写入这张表（或发 MQ 再落地），无需直接与弹窗渲染耦合。

### 4.4 PopupUserLog：用户行为日志（埋点 + 频控依据）

用于记录弹窗展示/点击/关闭/完成等行为：

* `id`
* `uid`
* `popup_code`
* `track_id`：本次展示/交互的唯一标识，用于关联一次完整的弹窗生命周期
* `event_type`：expose / click / close / complete
* `button_code`：primary / secondary / close 等
* `scene_code`
* `client_code`
* `device_id`
* `event_time`
* `extra`：JSON（自定义扩展）

实时频控建议主要依赖 Redis 计数和标记，数据库日志更偏向统计与审计。

---

## 五、接口设计

### 5.1 统一弹窗判断接口 `/api/popup/check`

**用途**：
前端在关键时机调用，用于获取“当前应该展示的弹窗列表”。

#### 5.1.1 请求参数（示例）

```json
POST /api/popup/check
{
  "uid": 123456,                   // 未登录可为 0 或 null
  "client_code": "MiniProgram",    // MiniProgram / H5 / Android / iOS 等
  "scene_code": "home_enter",      // app_launch / home_enter / order_finish / activity_center 等
  "app_version": "2.3.1",          // 客户端版本，可选
  "device_id": "xxx",              // 设备 ID，可选
  "channel_code": "wx",            // 渠道编码，可选
  "extra": {                       // 可扩展上下文信息
    "city_code": "440100",
    "is_new_user": true
  }
}
```

#### 5.1.2 返回参数（示例）

```json
{
  "should_popup": true,
  "popups": [
    {
      "popup_code": "christmas_2025",
      "popup_type": "activity",
      "title": "圣诞充值送好礼",
      "subtitle": "充越多送越多",
      "content": "圣诞期间充值满 100 送 20，数量有限，先到先得~",
      "image_url": "https://xxx/christmas.png",
      "style": {
        "theme": "dark",
        "layout": "center",
        "mask": true,
        "delay_seconds": 1,
        "show_close_button": true
      },
      "buttons": [
        {
          "button_code": "primary",
          "text": "立即参与",
          "action_type": "open_page",
          "action_value": "activity://christmas_2025"
        },
        {
          "button_code": "secondary",
          "text": "稍后再说",
          "action_type": "dismiss",
          "action_value": ""
        }
      ],
      "force": false,
      "priority": 3,
      "track_id": "pop_christmas_2025_u123456_20251211_01",
      "freq_policy": {
        "user_daily_limit": 1,
        "user_total_limit": 3,
        "seen_no_longer_show": false,
        "clicked_no_longer_show": true
      }
    }
  ]
}
```

说明：

* `should_popup = false` 时，`popups` 通常为空数组。
* `popups` 数组可以包含多个弹窗（前端按顺序依次弹），但大多数场景只返回 0 或 1 个。
* `track_id` 由后端生成，前端只负责在上报接口中透传即可。

### 5.2 行为上报接口 `/api/popup/report`

**用途**：
记录弹窗曝光、点击、关闭、完成等用户行为，为频控与数据分析提供依据。

#### 5.2.1 请求参数（示例）

```json
POST /api/popup/report
{
  "uid": 123456,
  "popup_code": "christmas_2025",
  "track_id": "pop_christmas_2025_u123456_20251211_01",
  "event_type": "click",         // expose / click / close / complete
  "button_code": "primary",      // primary / secondary / close 等
  "scene_code": "home_enter",
  "client_code": "MiniProgram",
  "device_id": "xxx",
  "timestamp": 1733904300000,
  "extra": {
    "from_page": "home",
    "to_page": "activity_christmas"
  }
}
```

#### 5.2.2 后端处理建议

* 将行为写入 `PopupUserLog`（可异步处理）。
* 根据 event_type 和 PopupConfig 的频控配置，更新 Redis 中的计数和标记：
    * `expose`：增加曝光计数；必要时标记 `seen_flag`。
    * `click`：增加点击计数；如果配置 `clicked_no_longer_show`，则标记后续不再展示。
    * `close`：如配置 `closed_no_longer_show`，则标记后续不再展示。
    * `complete`：可作为“业务完成”的一个信号，用于后续策略优化。

### 5.3 内部触发接口（业务“一句代码”）

为业务提供简单触发能力：

```java
public interface PopupTriggerService {

    /**
     * 触发一个弹窗事件（例如中奖、到账等）。
     * 业务只需指定 popupCode 和参数，具体展示时间由 /api/popup/check 决定。
     */
    void trigger(String popupCode, long uid, Map<String, Object> params);
}
```

调用示例（中奖弹窗）：

```java
popupTriggerService.trigger(
    "lottery_win_popup",
    uid,
    Map.of(
        "activity_name", activityName,
        "prize_name", prizeName,
        "coupon_code", couponCode,
        "amount", bonusAmount
    )
);
```

内部落地建议：

1. 将 `popupCode`、`uid`、`params` 序列化后写入 `PopupPending`（或发送 MQ 再落库）。
2. 根据业务需要设置 `scene_code`（例如建议在 `home_enter` 时弹）。
3. 设置合理的 `expire_time`（例如 24 小时后失效）。

---

## 六、后端决策流程（/api/popup/check 执行逻辑）

统一弹窗判断接口的核心流程可以拆分为以下步骤：

### 6.1 收集上下文

* 从请求中获取：
    * `uid`
    * `client_code`
    * `scene_code`
    * `app_version`
    * `device_id`
    * `channel_code`
    * `extra`（城市、新老用户等）
* 如有需要，可扩展：用户标签、会员等级等（从用户中心获取或缓存中获取）。

### 6.2 加载候选弹窗配置

* 从缓存（例如 Redis / 本地内存）中读取当前组织 / 平台下所有启用的 `PopupConfig`。
* 初步过滤：
    * 时间是否在 `start_time` ~ `end_time` 内。
    * 如果配置了 `daily_start_time` ~ `daily_end_time`，检查当前时间是否在该时间段内。

### 6.3 按场景、客户端、版本过滤

* 保留包含当前 `scene_code` 的配置。
* 保留匹配当前 `client_code` 的配置。
* 按版本约束过滤：
    * `min_app_version <= app_version <= max_app_version`（如有配置）。

### 6.4 按人群 / 用户条件过滤

* 判断当前用户是否满足：
    * 全量用户 / 登录用户 / 新用户 / 老用户。
    * 指定 uid 列表。
    * 标签、城市、渠道等规则。

### 6.5 结合 PopupPending（事件驱动弹窗）

* 根据 `uid`、`scene_code`（若有）查询 `PopupPending` 表，找到当前用户的待弹记录。
* 对每条待弹记录：
    * 检查 `expire_time` 是否过期。
    * 对应的 `PopupConfig` 是否仍然启用且满足基础条件。
    * 如匹配，将其对应模板参数 `params_json` 合并进后续模板渲染流程。
    * 根据策略在展示后将 `status` 标记为已展示或已消费。

### 6.6 频率控制与限流

基于 Redis 或其他高速缓存进行频控判断：

* 单用户维度：
    * `popup:user:{uid}:{popup_code}:date:YYYYMMDD` → 当日展示计数。
    * `popup:user:{uid}:{popup_code}:total` → 总展示计数。
* 全局维度：
    * `popup:global:{popup_code}:date:YYYYMMDD` → 全局当日展示计数。

若超过 `PopupConfig` 配置的限制（`user_daily_limit` / `user_total_limit` / `global_daily_limit`），则该弹窗从候选列表中剔除。

同时根据行为标记判断是否已经不应再展示：

* 用户曾经曝光、点击、关闭时是否已设置“不再展示”标志。
    * `popup:user:{uid}:{popup_code}:seen_flag`
    * `popup:user:{uid}:{popup_code}:clicked_flag`
    * `popup:user:{uid}:{popup_code}:closed_flag`

### 6.7 优先级排序与冲突处理

* 对剩余候选弹窗按 `priority`（和可选的 `level`）排序。
* 默认策略：
    * 返回优先级最高的 1 个弹窗。
* 可配置策略：
    * 某些场景允许返回多个弹窗（例如依次展示公告弹窗 + 活动弹窗）。
    * 此时根据 `allow_multi_popup` 标志和优先级决定返回若干条记录，前端按顺序弹出。

### 6.8 模板渲染（结合 PopupTemplate + 参数）

对最终决定需要返回的每一个 `popup`：

1. 判断是否启用模板：
    * `use_template_flag = true`：优先使用 PopupTemplate。
    * 否则使用配置中静态 `title`、`content` 等字段。

2. 如果使用模板：
    * 从缓存中加载 `PopupTemplate`。
    * 组装模板参数 Map：
        * 来自 `PopupPending.params_json`（业务参数）。
        * 来自通用上下文（如用户昵称、当前城市等）。
    * 调用模板引擎，将 `{{param_name}}` 替换为具体值：
        * `title = render(title_template, params)`
        * `content = render(content_template, params)`
        * `main_button_text = render(button_main_template, params)`
        * `secondary_button_text = render(button_sub_template, params)`
    * 如某些参数缺失，可按策略处理（保留占位符、替换为空或记录告警）。

3. 为该弹窗生成 `track_id`，写入返回结果，并预先在 Redis 中设置相应的计数 Key（如需）。

### 6.9 构造返回值

* 如果最终无任何弹窗可弹：
    * 返回：`should_popup = false`，`popups = []`。
* 如果有弹窗：
    * 返回：`should_popup = true`，并附上弹窗列表（内容 + 样式 + freq_policy + track_id 等）。

---

## 七、前端接入方案

### 7.1 调用时机建议

在以下关键时机统一调用 `/api/popup/check`：

1. 应用启动（`app_launch`）。
2. 进入首页（`home_enter`）。
3. 订单完成页展示时（`order_finish`）。
4. 进入活动中心、钱包等关键业务页面（`activity_center` 等）。
5. 其他需要运营控制的关键场景。

### 7.2 渲染与交互流程

1. 调用 `/api/popup/check`，传入 `uid + scene_code + client_code + app_version` 等上下文。

2. 若 `should_popup = false`，则不做任何弹窗。

3. 若 `should_popup = true` 且 `popups` 非空：
    * 按返回顺序依次展示弹窗（可以在前端封装一个统一弹窗组件）。
    * 根据 `force`、`show_close_button` 等配置控制交互行为。

4. 用户操作时：
    * 弹窗展示时立即上报 `expose`。
    * 点击主按钮/副按钮时上报 `click`，附带 `button_code`。
    * 用户点击关闭按钮时上报 `close`。
    * 某些业务完成行为可在合适时机上报 `complete`（如更新完成等）。

### 7.3 强制弹窗处理

对于 `force = true` 的强制弹窗：

* 前端在弹窗处理完成前，禁止返回/关闭当前页面（或限制关键操作）。
* 只有点击某些被允许的按钮（例如“我已阅读并同意”、“立即更新”）后才允许继续。

---

## 八、运营后台能力规划

1. **弹窗配置管理（PopupConfig）**
    * 列表查询、筛选（按组织、平台、类型、状态）。
    * 创建 / 编辑 / 下线。
    * 配置可视化：时间、人群、场景、优先级、频控等。
    * 支持复制配置、快速创建新弹窗。

2. **模板管理（PopupTemplate）**
    * 支持编辑标题、正文、按钮的模板。
    * 支持定义和展示 `params_meta`，提示运营本模板需要哪些参数。
    * 提供占位符预览和测试功能（输入模拟参数，预览实际文案）。

3. **待弹窗事件查看（PopupPending）**
    * 可查询某用户的待弹记录。
    * 支持人工失效/删除某条记录（紧急情况下使用）。

4. **数据报表与分析**
    * 统计每个弹窗的：
        * 曝光次数。
        * 点击次数。
        * 关闭次数。
        * 转化率（click/expose、complete/expose 等）。
    * 按时间、平台、版本、渠道维度进行分析。

---

## 九、非功能性要求

1. **性能**
    * `/api/popup/check` 为高频接口，需控制在尽量低的延迟（如 < 20ms）。
    * 在实现上尽量做到纯缓存（内存 + Redis）判断，不访问数据库。

2. **可用性与降级**
    * 若弹窗中台或 Redis 异常，应有兜底策略：
        * 可以直接返回 `should_popup = false`，避免影响主业务流程。
    * 行为上报接口 `/api/popup/report` 可异步处理，失败可重试或忽略，不能阻塞用户操作。

3. **安全与权限**
    * 后台管理操作需有严格权限控制，尤其是强制弹窗、协议弹窗等敏感配置。
    * 建议对关键变更（如开启强制更新弹窗）做操作日志及审批流程。

4. **审计与回溯**
    * `PopupConfig` 和 `PopupTemplate` 建议保留历史版本或变更记录，以便事后排查问题和回溯某一时间段配置。

---

## 十、演进与落地建议

1. **第一阶段：最小可用版本（MVP）**
    * 实现 /api/popup/check + /api/popup/report。
    * 建立 `PopupConfig` + 简单频控（只支持静态内容，不用模板）。
    * 接入一两个简单场景（如首页公告弹窗 + 活动弹窗）。

2. **第二阶段：模板与触发接入**
    * 增加 `PopupTemplate` + 简单模板引擎（支持 `{{var}}` 占位符）。
    * 增加 `PopupPending` 表和 `PopupTriggerService.trigger()` 接口。
    * 在典型业务场景（如中奖弹窗、到账弹窗）上试点事件驱动 + 模板化。

3. **第三阶段：全面统一与优化**
    * 逐步替换原有各种散落的弹窗接口，统一迁移到弹窗中台。
    * 引入多语言、多品牌、多渠道支持。
    * 完善报表与数据分析，支持 AB 实验与自动化策略优化。

通过以上设计，弹窗中台可以逐步从“统一弹窗接口”升级为“统一触达策略中心”，为活动营销、系统通知和用户体验提供坚实的基础设施。
