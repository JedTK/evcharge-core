先说一句结论：**加 `PopupTemplate` + 简单模板引擎是非常必要的升级**，能把「业务触发逻辑」和「展示文案/布局」完全解耦，让业务方只需要记住 `popup_code` + 参数即可。

下面我帮你**整合一份新的、比较完整的设计方案**，把「模板」这块也好好写进去，你可以直接当备份用。

---

## 一、模块名称：弹窗中台（Popup Center）

**核心能力：**

* 统一弹窗判断接口
* 统一弹窗配置与策略
* 统一内容模板（PopupTemplate）与模板渲染

一句话：**前端只负责问“现在要弹什么？”，业务只负责“触发哪个弹窗 + 给参数”，后端中台负责“算、配、渲、控”。**

---

## 二、现状与问题

### 2.1 现状

目前前端弹窗逻辑分散在多个业务接口里：

* 圣诞活动弹窗：需要调用「圣诞活动」专用 API。
* 公告弹窗：需要调用「公告列表 / 公告详情」API。
* 中奖提醒弹窗：需要调用「中奖」相关 API。
* 版本更新、强制协议等也各自有独立接口和判断逻辑。

每一种弹窗都有自己的一套判断规则和接口，导致：

1. 前端需要维护多套调用逻辑，增加开发成本和出错概率。
2. 弹窗优先级、频率、互斥规则无法统一，只能在各业务里“各搞一套”。
3. 想要新增一个弹窗类型时，需要前后端都改一轮，扩展成本高。
4. 无法从整体视角控制“用户看到的弹窗体验”，容易出现多弹、乱弹、频繁打扰等问题。

### 2.2 核心痛点

* **调用不统一**：前端不知道该调哪个接口，只能一个个业务判断。
* **逻辑不统一**：不同弹窗的“是否弹”、“多久弹一次”等逻辑各写一遍。
* **策略不好控制**：无法全局控制某段时间内用户被弹多少次、先弹哪个。
* **难以运营**：活动弹窗、版本弹窗、公告弹窗没有统一管理后台，运营配置成本高。
* **文案维护分散**：业务代码里到处写文案，参数拼接杂乱，更换文案就要改代码。

---

## 三、建设目标

通过建设「弹窗中台」及统一判断 API，实现：

1. **前端只调用一个接口**，由后端统一判断：

    * 现在要不要弹？
    * 弹哪个弹窗？
    * 弹几个？以什么顺序？

2. **配置化弹窗内容和策略**，无需频繁改代码上线：

    * 弹窗文案、图片、按钮、跳转链接统一配置。
    * 支持内容模板（`PopupTemplate`），通过 `${var}` 占位符注入业务参数。
    * 适配不同用户、不同平台、不同版本的展示规则。

3. **统一的频次控制与人群控制**：

    * 限制弹出次数、防骚扰。
    * 区分“全体用户”和“指定用户 / 用户群体”。

4. **统一的优先级与冲突处理**：

    * 当一个时间点有多个弹窗满足条件，按照优先级 / 规则进行决策。

5. **埋点与数据闭环**：

    * 统计弹窗曝光、点击、关闭、转化情况，为运营优化提供数据支撑。

6. **业务接入简单**：

    * 业务侧只需一句代码类似：
      `PopupCenter.trigger("WIN_PRIZE", uid, params)`
      不需要关心文案，直接交给模板引擎渲染。

---

## 四、业务范围与弹窗类型

统一纳入弹窗中台管理的弹窗类型（不限于）：

1. **活动类弹窗**

    * 圣诞活动、春节活动、充值送券、拉新活动等。

2. **系统公告类弹窗**

    * 系统维护公告、新功能公告、停服公告等。

3. **订单类 / 结果类弹窗**

    * 中奖提醒、优惠券到账提醒、订单异常提醒等。

4. **版本控制类弹窗**

    * 新版本提示、强制更新弹窗。

5. **协议类弹窗**

    * 隐私政策更新、用户协议更新、强制阅读并勾选。

后续可扩展其他类型，只要定义好配置 + 模板 + 判断规则即可接入。

---

## 五、核心功能需求

### 5.1 统一弹窗判断 API

前端只调用一个统一接口（例如：`/api/popup/check`），传入上下文参数，由后端返回当前需要展示的弹窗列表（或单个弹窗）。

**前端请求参数（示例）：**

* `uid`：用户ID（未登录可为空或0）。
* `client_code`：客户端编码（MiniProgram / H5 / iOS / Android 等）。
* `scene_code`：当前场景，比如：

    * `app_launch`：APP/小程序启动
    * `home_enter`：进入首页
    * `order_finish`：订单完成页
    * `activity_center`：活动中心
* `app_version`：客户端版本号（可选）。
* `extra`：其他扩展信息（渠道、城市、是否新用户等）。

**后端返回（示例）：**

* `should_popup`: 是否需要弹窗（布尔）
* `popups`: 弹窗列表（0~N 个，一般是0或1个）

每个弹窗包含：

* 基础信息：

    * `popup_code`：弹窗编码
    * `popup_type`：弹窗类型（活动/公告/中奖/版本/协议等）
    * `track_id`：用于埋点与频控关联的唯一标识（可选）

* 渲染内容（已渲染好的内容，前端直接展示）：

    * `title`：标题
    * `sub_title`：副标题（可选）
    * `content`：正文内容（支持富文本）
    * `image_url`：主图或背景图（可选）
    * `buttons`：按钮配置列表

        * `button_code`：按钮编码（如 `primary`、`secondary`）
        * `text`：按钮文案
        * `action_type`：行为类型（`OPEN_URL` / `NAVIGATE_PAGE` / `CLOSE_ONLY` / `CUSTOM_EVENT` 等）
        * `action_value`：行为值（URL、页面路由、事件参数等）

* 展示策略：

    * `force`：是否强制弹窗（不可关闭或必须处理）
    * `can_close`：是否允许用户关闭
    * `delay_ms`：延迟多少毫秒后弹出
    * 其他 UI 相关参数（蒙层、位置等）

> 这里的文案内容优先由 **模板引擎渲染后输出**，前端尽量不做文案拼接。

---

### 5.2 弹窗配置模型（PopupConfig）

`PopupConfig` 是弹窗中台的核心配置实体，用于描述“什么条件下，可以弹出什么类型的弹窗”。

建议字段（简化版逻辑模型）：

1. **基础信息**

* `id`
* `popup_code`：弹窗编码（业务和前端都只需要记住它）
* `popup_name`：弹窗名称（例如“2025圣诞活动弹窗-新用户”）
* `popup_type`：弹窗类型（活动 / 公告 / 中奖 / 版本 / 协议 …）
* `organize_code`：组织编码
* `platform_code`：平台编码（mini_program / console / merchant 等）

2. **模板关联**

* `template_code`：**关联内容模板 `PopupTemplate` 的编码**

    * 说明：

        * 同一个 `template_code` 可以被多个 `PopupConfig` 复用（例如不同组织/平台使用同一模板，但策略不同）。
        * 模板中使用 `${var}` 占位符，运行时由业务参数 + 中台计算结果进行渲染。
* 可选：`template_params_default`：JSON，定义默认参数（如默认活动名称等）。

3. **展示内容（兜底/非模板场景）**

即使有模板，有些简单弹窗也可以不依赖模板，直接用固定文案，这里可以保留兜底字段：

* `title_fixed`
* `sub_title_fixed`
* `content_fixed`
* `image_url_fixed`
* `button_json_fixed`（JSON结构，描述按钮配置）

> 当 `template_code` 不为空时，优先使用模板渲染；
> 当模板渲染失败或未配置模板时，可以回退到 fixed 配置。

4. **时间与有效期**

* `start_time`
* `end_time`
* 可选：`daily_time_range`（如 09:00–21:00）

5. **目标人群 / 定向规则**

* `audience_type`：全量 / 登录用户 / 指定用户 / 标签用户
* `uid_list`（可选）：指定用户列表
* `tag_code_list`（可选）：用户标签
* 客户端相关条件：

    * `client_code_list`
    * `app_version_min` / `app_version_max`
    * 其他业务自定义过滤条件（城市、渠道、新老用户等）

6. **频率控制 / 限流规则**

* 开关：`enable_frequency_limit`
* 每用户：

    * `user_daily_max`：每天最多弹出次数
    * `user_total_max`：活动期最多弹出次数
    * `user_seen_no_more`：看过一次就不再弹（基于曝光）
    * `user_clicked_no_more`：点击主按钮后不再弹
    * `user_closed_no_more`：关闭也算处理过，不再弹
* 全局：

    * `global_daily_max`
* 场景：

    * `force_in_scene`：某些场景必弹一次（例如 `app_launch`）

7. **优先级与冲突处理**

* `priority`：数字，越小优先级越高（如 1~10）
* `allow_multiple`：是否允许与其他弹窗一起按顺序弹出

8. **其他配置**

* `force_popup`：是否强制弹窗（必须处理）
* `delay_ms`
* `ab_test_bucket` / `gray_ratio` 等灰度字段
* `track_event_code`：埋点事件编码

---

### 5.3 内容模板（PopupTemplate）与简单模板引擎

这是你新提的重点，我单独拉一个小节讲清楚。

#### 5.3.1 PopupTemplate 模型

`PopupTemplate` 用来描述弹窗的**内容结构**和**可替换变量**，可以被多个 `PopupConfig` 复用。

**建议字段（逻辑模型）：**

* 基础信息：

    * `id`
    * `template_code`：模板编码（唯一）
    * `template_name`：模板名称（如“中奖提醒模板V1”）
    * `template_type`：类型（如：`TEXT_ONLY`、`RICH_TEXT`、`JSON_LAYOUT` 等）

* 模板内容：

    * `title_template`：标题模板，例如：
      `恭喜您获得${prizeName}`
    * `sub_title_template`：副标题模板（可选）
    * `content_template`：正文模板，例如：
      `您在【${activityName}】活动中获得${amount}元优惠券，已发放至账号 ${userMobile}。`
    * `button_template_json`：按钮区域模板（JSON 格式），里面也允许出现 `${var}` 占位符
      示例：

      ```json
      {
        "buttons": [
          {
            "button_code": "primary",
            "text": "立即查看${activityShortName}",
            "action_type": "OPEN_URL",
            "action_value": "/pages/activity/detail?id=${activityId}"
          },
          {
            "button_code": "secondary",
            "text": "知道了",
            "action_type": "CLOSE_ONLY"
          }
        ]
      }
      ```

* 变量说明（可选，但非常推荐）：

    * `vars_schema_json`：用 JSON 描述本模板支持的变量名、类型和说明，例如：

      ```json
      {
        "prizeName": {"type": "string", "desc": "奖品名称"},
        "activityName": {"type": "string", "desc": "活动名称"},
        "amount": {"type": "number", "desc": "金额，单位元"},
        "userMobile": {"type": "string", "desc": "用户手机号脱敏"},
        "activityId": {"type": "string", "desc": "活动ID"}
      }
      ```

* 其他：

    * `lang` / `locale`（后续要做多语言时可以用）
    * `status`：启用/停用
    * `remark`

#### 5.3.2 简单模板引擎设计

**目标：**

* 支持 `${var}` 占位符替换；
* 尽量简单、轻量，不必上来就引入复杂模板引擎（比如 Freemarker）；
* 后续如果要换成更强的模板引擎，保留接口即可。

**核心能力：**

1. **变量替换**

    * 输入：模板字符串 `template`，参数 Map：`params`。
    * 将模板中 `${key}` 替换为 `params.get("key")` 的字符串形式。
    * 若某变量缺失：

        * 可配置策略：空字符串 / 默认值 / 抛异常 / 保留原样。

2. **支持 JSON 模板渲染**

    * 对 `button_template_json` 这样的 JSON 字符串，先整体作为文本进行 `${var}` 替换，再反序列化成对象返回给前端。

3. **类型格式化（可选）**

    * 对金额、时间等字段，可支持简单格式化规则，比如：

        * `${amount}` 默认 toString；
        * `${amount|fixed2}` 保留两位小数；
        * `${date|yyyy-MM-dd}` 做日期格式化（可作为扩展点）。

> 先期可以只做 `${var}` 替换，等模板使用多了再扩展格式化语法。

#### 5.3.3 业务调用视角

**业务方只需要做两件事：**

1. 决定触发哪个弹窗：`popup_code`
2. 准备好模板所需参数：`Map<String, Object> params`

示例（伪代码）：

```java
PopupTriggerRequest req = new PopupTriggerRequest();
req.setPopupCode("WIN_PRIZE");
req.setUid(userId);
req.setSceneCode("order_finish");
req.setTemplateParams(Map.of(
    "prizeName", "双旦豪礼",
    "activityName", "圣诞充值返现活动",
    "amount", new BigDecimal("20.00"),
    "userMobile", "138****0000",
    "activityId", "ACT20251225"
));

popupCenterService.trigger(req);
```

中台保存这次“待弹记录”（或者直接作为实时上下文）→ 用户下次在对应场景调用 `/api/popup/check` 时，
中台从 `PopupConfig` + `PopupTemplate` + `templateParams` 渲染出最终弹窗内容，返回给前端。

---

### 5.4 判断逻辑（后端决策流程）

统一弹窗判断接口大致流程：

1. **收集上下文**

    * 根据前端传入的 `uid / client_code / app_version / scene_code / extra` 等，结合业务方通过 `trigger` 写入的上下文（如中奖数据）。

2. **候选弹窗筛选**

    * 从 `PopupConfig` 中找出：

        * 时间有效的配置
        * 场景匹配的配置
        * 组织/平台匹配的配置
        * 人群规则匹配的配置（uid / 标签 / 渠道等）

3. **频率限制校验**

    * 根据用户行为记录（expose/click/close/complete）判断是否达到频率上限；
    * 不满足频控条件的弹窗被剔除。

4. **优先级排序与冲突处理**

    * 对剩余候选弹窗，按 `priority` 排序；
    * 决策只返回：

        * 最高优先级的一个，或者
        * 多个（当 `allow_multiple=true` 且策略允许时）。

5. **模板渲染**

   对每一个最终要返回的弹窗：

    * 拿到 `PopupConfig.template_code` → 查询 `PopupTemplate`
    * 拿到对应的 `template_params`（可以来自触发记录 / 实时计算）
    * 调用模板引擎进行渲染：

        * 标题、正文、按钮 JSON 等都做 `${var}` 替换
    * 渲染失败时：

        * 可以回退使用 `PopupConfig` 中的 `*_fixed` 字段；
        * 或者直接丢弃这个弹窗（同时报警）。

6. **返回结果**

    * `should_popup = false`：没有可用弹窗
    * `should_popup = true` + `popups = [...]`：返回渲染后的弹窗列表（一般1个）

---

### 5.5 行为上报与数据统计

为了支撑频控与效果评估，需要统一设计“行为上报接口”，例如：`/api/popup/report`。

1. **上报事件类型**

    * `expose`：弹窗曝光（展示）
    * `click`：点击某个按钮
    * `close`：用户主动关闭弹窗
    * `complete`：完成指定业务动作（如已升级、已参加活动）

2. **上报字段示例**

    * `popup_code`
    * `track_id`
    * `uid`
    * `event_type`（expose/click/close/complete）
    * `button_code`（主按钮、副按钮）
    * `scene_code`
    * `timestamp`
    * 其他：渠道、device_id、app_version 等

3. **用途**

    * 支撑频控逻辑（看过一次不再弹 / 点击后不再弹等）
    * 统计曝光数 / 点击数 / 转化率
    * 分平台、分人群分析效果

---

## 六、前端接入方式（简要）

1. 在「应用启动」「进入首页」「订单完成页」等关键节点统一调用：

    * `GET /api/popup/check`
    * 参数：`uid / client_code / scene_code / app_version / extra`

2. 根据返回结果：

    * `should_popup = false`：不弹。
    * `should_popup = true`：

        * 按顺序遍历 `popups` 列表，渲染弹窗。
        * 文案、按钮、跳转等信息全部由接口返回。

3. 用户每一次操作触发行为上报：

    * `POST /api/popup/report`
    * 上报 `popup_code / track_id / event_type / button_code / scene_code / uid` 等。

前端不需要自己拼文案，也不关心 `${var}`，所有参数由后端渲染好再给。

---

## 七、非功能性要求

1. **可配置与扩展性**

    * 弹窗内容、模板、规则尽量配置化，通过后台即可新增/下线弹窗。
    * 新增弹窗类型时，只需增加类型枚举 + 少量后端逻辑，不改前端调用方式。

2. **性能**

    * `/api/popup/check` 请求应尽可能轻量，优先使用缓存（配置缓存 + 模板缓存）。
    * 频控与行为记录可使用 Redis + 异步落库方式。

3. **稳定性与安全**

    * 模板渲染失败必须有兜底策略（fallback 文案 / 不弹）。
    * 防止单个错误配置导致所有用户无限弹窗。

4. **运营友好**

    * 后台界面支持：

        * PopupConfig 列表 + 编辑
        * PopupTemplate 编辑（模板文本 + 变量说明）
        * 在线预览：填入一组示例参数，预览渲染后的弹窗文案和按钮。

---

## 八、小结与一点意见

* 你提出的 **`PopupTemplate` + `${var}` 模板引擎** 非常关键，它真正做到：

    * 业务逻辑只知道 `popup_code` 和「我要传的几个参数」；
    * 文案、排版、跳转全部交给配置 + 模板来控制；
    * 运营可以独立改文案、做 ABTest，业务代码不用动。

* 从实现顺序上，建议：

    1. 先完成 **PopupConfig + 判断接口 + 频控**（以固定文案为主的 MVP）。
    2. 再接入 **PopupTemplate + 简单模板引擎**，从“中奖类”“活动类”这类强依赖参数的弹窗先落地。
    3. 后面根据需要再升级到多语言、格式化语法、复杂布局。

如果你需要的话，我可以下一步帮你再拆一版：
*数据库表结构（PopupConfig / PopupTemplate / PopupTrigger / PopupLog）+ Java 实体类 & Service 接口草图*，直接对着写代码那种。
