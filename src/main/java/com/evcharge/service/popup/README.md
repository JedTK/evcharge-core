## 一、模块名称：弹窗中台（Popup Center）

* 核心能力：统一弹窗判断接口 + 统一弹窗配置与策略

---

## 二、现状与问题

### 2.1 现状

目前前端弹窗逻辑分散在多个业务接口里：

* 圣诞活动弹窗：需要调用「圣诞活动」专用 API。
* 公告弹窗：需要调用「公告列表 / 公告详情」API。
* 中奖提醒弹窗：需要调用「中奖」相关 API。
* 版本更新、强制协议等也各自有独立接口和判断逻辑。

每一种弹窗都有自己的一套判断规则和接口，导致：

1. 前端需要维护多套调用逻辑，增加开发成本和出错概率。
2. 弹窗优先级、频率、互斥规则无法统一，只能在各业务里“各搞一套”。
3. 想要新增一个弹窗类型时，需要前后端都改一轮，扩展成本高。
4. 无法从整体视角控制“用户看到的弹窗体验”，容易出现多弹、乱弹、频繁打扰等问题。

### 2.2 核心痛点

* **调用不统一**：前端不知道该调哪个接口，只能一个个业务判断。
* **逻辑不统一**：不同弹窗的“是否弹”、“多久弹一次”等逻辑各写一遍。
* **策略不好控制**：无法全局控制某段时间内用户被弹多少次、先弹哪个。
* **难以运营**：活动弹窗、版本弹窗、公告弹窗没有统一管理后台，运营配置成本高。

---

## 三、建设目标

通过建设「弹窗中台」及统一判断 API，实现：

1. **前端只调用一个接口**，由后端统一判断：

    * 现在要不要弹？
    * 弹哪个弹窗？
    * 弹几个？以什么顺序？
2. **配置化弹窗内容和策略**，无需频繁改代码上线：

    * 弹窗文案、图片、按钮、跳转链接统一配置。
    * 适配不同用户、不同平台、不同版本的展示规则。
3. **统一的频次控制与人群控制**：

    * 限制弹出次数、防骚扰。
    * 区分“全体用户”和“指定用户 / 用户群体”。
4. **统一的优先级与冲突处理**：

    * 当一个时间点有多个弹窗满足条件，按照优先级 / 规则进行决策。
5. **埋点与数据闭环**：

    * 能统计某弹窗的曝光、点击、关闭情况，为后续运营优化提供数据支撑。

一句话：**前端只负责问：现在应该弹什么？后端给出“弹或不弹 + 具体内容 + 展示策略”**。

---

## 四、业务范围与弹窗类型

弹窗中台统一管理的弹窗类型（不限于）：

1. 活动类弹窗

    * 圣诞活动、春节活动、充值送券、拉新活动等。
2. 系统公告类弹窗

    * 系统维护公告、新功能公告、停服公告等。
3. 订单类 / 结果类弹窗

    * 中奖提醒、优惠券到账提醒、订单异常提醒等。
4. 版本控制类弹窗

    * 新版本提示、强制更新弹窗。
5. 协议类弹窗

    * 隐私政策更新、用户协议更新、强制阅读并勾选。

后续可扩展其他弹窗类型，只要定义好配置与判断规则即可接入中台。

---

## 五、核心功能需求

### 5.1 统一弹窗判断 API

前端只调用一个统一接口（例如：`/api/popup/check`），传入上下文参数，由后端返回当前需要展示的弹窗列表（或单个弹窗）。

**前端传入（示例）：**

* `uid`：用户ID（未登录可为空或0）。
* `client_code`：客户端编码（例如：MiniProgram、H5、iOS、Android）。
* `scene_code`：当前场景，比如：

    * `app_launch`：APP/小程序启动
    * `home_enter`：进入首页
    * `order_finish`：订单完成页
    * `activity_center`：活动中心

* `app_version`：客户端版本号（可选）。
* `extra`：其他扩展信息（渠道、城市、是否新用户等）。

**后端返回（示例）：**

* `popups`: 弹窗列表（通常是 0~N 个，绝大多数场景只返回 0 或 1 个）。

    * 每个弹窗包含：

        * 弹窗标识：`popup_code`
        * 展示类型：`popup_type`（活动/公告/中奖/版本/协议等）
        * 标题、内容、副标题、图片地址
        * 按钮配置（按钮文案、样式、点击后行为、跳转地址等）
        * 展示策略（是否强制、是否可关闭、展示位置、蒙层形式等）
        * 频控信息（给前端用作上报的 key，如 `track_id`）

前端拿到结果后，只负责按照内容渲染弹窗，并在用户操作后上报行为事件。

---

### 5.2 弹窗配置模型（后端中台配置）

中台支持配置每一个弹窗的属性，主要包括：

1. **基础信息**

    * 弹窗编码：`popup_code`
    * 弹窗名称：用于运营和开发识别（如“2025圣诞活动弹窗”）
    * 弹窗类型：活动 / 公告 / 中奖 / 版本 / 协议 …
    * 组织 / 平台维度：`organize_code`、`platform_code` 等

2. **展示内容**

    * 标题
    * 正文内容（支持富文本或简单格式）
    * 图片/背景图URL（可选）
    * 按钮区配置：

        * 主按钮文案 + 行为（跳转链接、打开页面、执行特定协议等）
        * 副按钮文案 + 行为（例如“暂不参与”、“稍后再说”）
    * 是否展示关闭按钮，关闭按钮文案（如“我知道了”）

3. **时间与有效期**

    * 生效开始时间 `start_time`
    * 生效结束时间 `end_time`
    * 可选：每天的展示时间段（例如每天 9:00–21:00 才弹）

4. **目标人群 / 定向规则**

    * 是否对全体用户生效
    * 是否仅对登录用户生效
    * 指定用户列表（uid 列表 / 用户标签）
    * 客户端条件：

        * 平台（MiniProgram/H5/App）
        * 客户端版本范围（例如版本 < 2.3.0 需要弹强更）

5. **频率控制 / 限流规则**

    * 是否启用频控
    * 每用户维度：

        * 每天最多弹出次数（如：每用户每天最多 1 次）
        * 整个活动期最多弹出次数（如：活动期最多 3 次）
        * 每次进入特定场景是否必弹一次
    * 全局维度：

        * 全体用户每天最多展示次数（避免活动配置错误导致刷量）
    * 是否“看过一次不再弹”：

        * 看过（曝光）就不再弹
        * 点击主按钮才算“完成”，以后不再弹
        * 关闭也算“已处理”，以后不再弹

6. **优先级与冲突处理**

    * 弹窗优先级：1~10，数字越小优先级越高（举例）。
    * 同一场景多个弹窗满足条件时：

        * 默认只弹优先级最高的一个。
        * 或支持配置“允许多个弹窗按顺序依次弹出”。

7. **其他配置**

    * 是否强制弹窗（必须处理完才可继续操作，如强制更新、强制协议）
    * 是否支持“延迟N秒后弹出”（防止刚进页面时就打扰用户）
    * AB测试/灰度字段（如灰度比例、灰度标识等）
    * 埋点事件ID，用于统计曝光、点击、关闭

---

### 5.3 判断逻辑（后端决策流程）

统一弹窗判断接口的核心流程：

1. **收集上下文**

    * 根据前端传入的 `uid / client_code / app_version / scene_code / ` 等。

2. **候选弹窗筛选**

    * 从配置中筛选出“当前时间有效”的弹窗。
    * 按场景等条件过滤。
    * 按用户人群条件过滤（指定用户、标签、新老用户等）。

3. **频率限制校验**

    * 结合用户的历史曝光/点击记录，判断是否达到弹出上限。
    * 排除已达到频次限制的弹窗。

4. **优先级排序与冲突处理**

    * 对剩余弹窗按优先级排序。
    * 按策略决定返回一个还是多个弹窗：

        * 常规场景：只返回优先级最高的一个弹窗。
        * 特殊场景（可配置）：返回多个，前端按顺序依次弹。

5. **返回结果**

    * 若没有符合条件的弹窗：`should_popup=false`，`popups=[]`。
    * 若有：`should_popup=true`，附带弹窗内容和埋点/频控所需字段。

---

### 5.4 行为上报与数据统计

为了支撑频控与效果评估，需要统一设计“行为上报接口”：

1. **上报事件类型**

    * `expose`：弹窗曝光（展示）事件。
    * `click`：点击某个按钮事件。
    * `close`：用户主动关闭弹窗。
    * `complete`：业务定义的“完成动作”，例如做了更新、参加了活动等。

2. **上报字段示例**

    * `popup_id` / `popup_code`
    * `uid`
    * `event_type`（expose/click/close/complete）
    * `button_code`（如主按钮、副按钮）
    * `scene_code`
    * `timestamp`
    * 其他埋点需要的信息（例如渠道、device_id等）。

3. **用途**

    * 用于频率控制判断用户是否已经看过 / 点击过。
    * 统计各类弹窗的曝光数、点击数、转化率，为运营策略提供数据。

---

## 六、前端接入方式（简要）

1. 在「应用启动」或「进入核心页面」等关键节点，统一调用：

    * `/api/popup/check`，传入用户信息 + 场景码。
2. 根据返回结果：

    * `should_popup = false`：不做任何弹窗。
    * `should_popup = true` 且 `popups` 非空：

        * 按返回的顺序/优先级渲染弹窗。
3. 用户对弹窗的每一次操作（展示、点击、关闭），调用上报接口：

    * `/api/popup/report`，用于记录行为与支持频控。

---

## 七、非功能性要求

1. **可配置与扩展性**

    * 所有弹窗内容与规则尽量配置化，通过后台就能新增/下线一个弹窗。
    * 新增弹窗类型时，只需新增类型枚举与少量业务逻辑，不改变前端调用方式。


---

## 八、小结

通过这个「弹窗中台 + 统一判断 API」，我们希望达成：

* 前端：**只调一个接口**就搞定所有弹窗。
* 后端：统一管理各种弹窗逻辑，支持优先级、人群、频次等策略。
* 运营：通过配置就能上线/下线一个弹窗，活动弹窗快速迭代。
* 产品：用户不会被乱七八糟的弹窗打扰，整体体验可控。
