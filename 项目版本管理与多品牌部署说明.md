# 项目版本管理与多品牌部署标准

> 适用于：所有多品牌、多版本的系统项目
> 目标：在多品牌、多环境、多版本并行运行的情况下，保证系统高可维护性、可升级性、结构清晰，避免“代码复制粘贴 + 手工改配置”的混乱局面。

---

# 一、数据库版本管理：Flyway（目标规范）

> 当前可暂时未启用，作为规范目标；后续学习完成后逐步切换到 Flyway 管理。

系统推荐使用 **Flyway** 对 MySQL 数据结构进行版本控制。
所有表结构、字段修改、索引变动，最终都应通过 Flyway 统一执行。

## 1.1 目录结构（固定标准）

```bash
src/main/resources/db/migration/
    V1__init.sql
    V2__add_charge_order_columns.sql
    V3__create_investor_income_summary.sql
    V4__modify_device_table_add_meter_id.sql
```

## 1.2 规范要求

1. 所有 SQL 变更必须以 `Vxxx__描述.sql` 形式存放到上述目录（`xxx` 为递增版本号）。
2. 程序启动时自动执行“未执行”的脚本，不允许线下手工在数据库里改结构。
3. 所有品牌、所有版本，数据库结构统一由 Flyway 控制（禁止直接在生产库手工改字段）。
4. 每一个 **正式发行版本（Git Tag）** 必须包含完整且匹配的 Flyway 脚本，以保证任意品牌只要升级到该 Tag，就能自动完成数据库升级。

## 1.3 引入 Flyway 的收益

* **结构统一**：不同品牌、不同环境的数据库结构自动保持一致。
* **升级可控**：版本升级与回滚有统一的脚本记录，便于排查问题。
* **环境清晰**：测试、预发、生产的结构不再“各自飞”，做到一键对齐。
* **降低风险**：不需要 DBA 手工执行 SQL，减少误删表、误更新字段的事故。

---

# 二、Git 管理规范：分支与 Tag

核心理念：

> **分支管理开发流程，Tag 管理正式版本。**

分支是“过程”，Tag 是“结果”。

---

## Git仓库命名方式：
推荐用统一格式：
```text
evcharge-{layer}-{module}-{extra}
```
各字段含义：

* `layer`：按“领域/层级”划分

    * `core`：核心业务后端（订单、账户、投资、对账等）
    * `device`：物联网 & 设备接入相关
    * `ai`：AI / 算法 / FAQ / 语音机器人相关
    * `web`：后台管理 / 官网 / H5
    * `miniapp`：小程序
    * `ops`：运维 / 脚本 / 部署 / 监控
    * `infra`：公共组件、SDK、工具库（被多个服务依赖）

* `module`：具体功能域，比如 `charge-api`、`console-api`、`investor-api`、`device-gateway`

* `extra`：可选，补充说明，比如 `v2`、`demo`、`experimental` 等


## 2.1 Git 分支策略（GitFlow）与命名规范

采用标准化 Git Flow，保证多人协作时不会乱：

```text
main                    ← 稳定主线（只存放可发布代码）
develop                 ← 开发主线（集成所有开发完成的功能）
feature/*               ← 功能开发分支
release/*               ← 准备发布分支
hotfix/*                ← 线上紧急修复分支
```

### 2.1.1 各分支角色

* **main**

  * 只存放已上线或可随时上线的代码。
  * 所有 Tag 都从 main 分支打出。
* **develop**

  * 日常开发主线，集成功能后统一联调。
  * 新功能开发完成后，通过 PR 合并到 develop。
* **feature/***（功能开发分支）

  * 命名示例：

    * `feature/charge-card-discount`
    * `feature/investor-income-summary`
  * 从 `develop` 分支拉出，开发完成后合并回 `develop`，然后删除该 feature 分支。
* **release/***（预发布分支）

  * 命名示例：

    * `release/1.2.0`
  * 当准备发版时，从 `develop` 拉出 `release/x.y.z` 分支，只接收：

    * Bug 修复
    * 文档调整
    * 配置类微调（不再接收新功能）
* **hotfix/***（线上紧急修复）

  * 命名示例：

    * `hotfix/fix-charge-balance-freeze`
  * 当线上发现严重问题，从 `main` 拉出 hotfix 分支：

    1. 修复后合并回 `main` 并打新 Tag；
    2. 同步合并回 `develop`，避免下个版本重复出现。

### 2.1.2 GitFlow 简化流程图

```text
               +-------------------+
               |       main        |
               +---------+---------+
                         ^
                         |
                    +----+----+      hotfix/*
                    |  Tag   |<-----------------+
                    +----+---+                  |
                         ^                      |
                     merge                      |
                         ^                      |
+---------------+   +---+-----------------------+----+
|   feature/*   |-->|          develop               |
+---------------+   +---+-----------------------+----+
                         |
                         |  cut release
                         v
                    +----+-------------------+
                    |     release/x.y.z      |
                    +------------------------+
```

你可以把这个流程记成一句话：
**“功能走 feature → develop，发版走 release → main＋Tag，线上问题走 hotfix。”**

---

## 2.2 Git Tag 规范（正式版本号）

Tag 的作用：**标记一个可用于生产环境的稳定版本**。

### 2.2.1 Tag 命名规范

统一使用语义化版本号：

```text
v主版本号.次版本号.修订号

例：v1.0.1　v1.1.0　v1.2.5
```

常见规则建议：

* **主版本号**（Major）：有不兼容变更、架构改动时 +1。
* **次版本号**（Minor）：新增较大功能、模块时 +1。
* **修订号**（Patch）：Bug 修复、小改动时 +1。

### 2.2.2 Tag 的使用场景

* 用于 **打包发布**：正式部署包必须来源于某个 Tag。
* 便于 **多品牌不同版本共存**。
* 每个 Tag 对应：

  * 一套固定的源代码
  * 一套完整的 Flyway 脚本（目标状态）
  * 一套可重现的构建产物（JAR）

---

## 2.3 多品牌运行不同 Tag 版本示例

| 品牌    | 运行的版本（Tag） |
| ------ | ----------------|
| 元气充   | v1.2.0         |
| 品牌B    | v1.0.1         |
| 品牌C    | v1.1.3         |


部署方式示例：

```bash
# 部署品牌A用的版本
git checkout v1.0.1
mvn clean package -DskipTests

# 部署品牌B用的版本
git checkout v1.2.0
mvn clean package -DskipTests
```

特点：

* 支持不同品牌运行不同版本；
* 品牌之间互不影响；
* 不需要复制项目代码，也不需要用多个分支长期分裂维护。

**这就是大厂在多品牌、多版本并行时常用的标准做法。**

---

# 三、一套代码 → 多版本 JAR → 多套配置目录（多品牌部署标准）

我们采用的总体架构：

> **一套代码仓库 + 多个版本 JAR + 每个品牌独立配置目录 + 分布式部署**

从而支持 N 个品牌、N 个版本并行运行。

---

## 3.1 标准部署目录结构示例

```bash
/opt/evcharge/brandA/
    evcharge-v1.2.0.jar
    config/
        release/application.yml

/opt/evcharge/brandB/
    evcharge-v1.0.1.jar
    config/
        release/application.yml

/opt/evcharge/brandC/
    evcharge-v1.1.3.jar
    config/
        release/application.yml
```

说明：

* **每个品牌有自己的根目录**：`/opt/evcharge/brandA`、`/opt/evcharge/brandB` ……
* JAR 文件名建议带上版本号：`evcharge-v1.2.0.jar`。
* 每个品牌有独立的 `config` 目录，配合环境子目录（`localhost/dev/release`）。

---

## 3.2 多品牌部署标准（建议规范）

1. **目录命名约定**

   * 根目录：`/opt/evcharge/<brand_code>/`
   * 例如：

     * `brand_code = yuanqichong` → `/opt/evcharge/yuanqichong/`
     * `brand_code = partnerB`    → `/opt/evcharge/partnerB/`

2. **端口规划建议**

   * 为避免冲突，可约定：

     * 元气充：70xx 段，例如 `7091`
     * 品牌B：71xx 段
     * 品牌C：72xx 段
   * 同机部署时必须确保端口不冲突。

3. **域名与环境约定（示例）**

   * 测试环境：`test-<brand>.example.com`
   * 预发环境：`pre-<brand>.example.com`
   * 生产环境：`<brand>.example.com`

4. **配置隔离要求**

   * 每个品牌必须使用独立的：

     * 数据库库名
     * Redis 前缀 / 库号
     * MQ Topic / Group（视实际情况）
   * 确保任何一品牌出现问题不会影响其他品牌。

5. **部署矩阵示例**

```text
品牌     环境       机器/容器            JAR 版本      配置目录
元气充    生产       prod-node-01        v1.2.0       /opt/evcharge/yuanqichong/config/release
品牌B     生产       prod-node-02        v1.0.1       /opt/evcharge/partnerB/config/release
品牌C     测试       test-node-01        v1.1.3       /opt/evcharge/partnerC/config/dev
```

这样一来，**品牌与版本、环境之间的关系一目了然**。

---

# 四、配置文件必须独立管理（与代码彻底解耦）

由于：

* 多品牌间完全独立；
* 不同品牌可能使用不同版本代码；
* 不同品牌可能使用不同的数据库、Redis、MQ；
* 各品牌通常部署在不同机器上，或者至少是不同目录、不同端口；
* 测试/预发/生产各有独立配置。

因此，**配置文件必须与代码彻底分离、外置管理**。

---

## 4.1 标准外置配置结构

建议结构如下：

```bash
/opt/evcharge/brandA/config/
    localhost/application.yml
    dev/application.yml
    release/application.yml

/opt/evcharge/brandB/config/
    localhost/application.yml
    dev/application.yml
    release/application.yml
```

启动命令示例（Spring Boot）：

```bash
java -jar evcharge-v1.2.0.jar \
  --spring.profiles.active=release \
  --spring.config.additional-location=/opt/evcharge/brandA/config/release/
```

要点：

* 不同环境使用不同 profile，例如：`localhost/dev/release`。
* 配置文件在升级 JAR 时 **可以不动**，只在有配置变化时才改。
* 即使同一台机器部署多个品牌，也不会互相覆盖配置。

---

# 五、版本升级流程规范

版本升级是多品牌多版本体系的关键环节。建议严格按步骤执行。

以“将品牌 A 从 v1.0.1 升级到 v1.2.0”为例。

## 5.1 升级前准备

1. **确认目标 Tag**

   * 确定要升级到的版本号，如：`v1.2.0`。
2. **代码打包**

   ```bash
   git checkout v1.2.0
   mvn clean package -DskipTests
   ```
3. **备份**

   * 备份当前 JAR：`evcharge-v1.0.1.jar`。
   * 备份当前配置（可选，但推荐）。
   * 数据库备份（生产环境强烈建议全库备份或关键表备份）。

## 5.2 升级步骤

1. **停止当前服务**

   * 通过 PM2 停止：

     ```bash
     pm2 stop evcharge-brandA
     ```
   * 或其他方式停止进程。

2. **替换 JAR**

   * 将新构建的 `evcharge-v1.2.0.jar` 拷贝到品牌 A 目录：

     ```bash
     cp target/evcharge-v1.2.0.jar /opt/evcharge/brandA/
     ```
   * 保留旧 JAR（例如重命名为 `evcharge-v1.0.1.jar.bak`）。

3. **确认配置**

   * 一般情况下沿用原来的 `/opt/evcharge/brandA/config/release/application.yml`。
   * 若新版本需要新增配置项，请先在测试环境验证。

4. **启动新版本**

   * 通过 PM2 启动（见后文 PM2 模板）：

     ```bash
     pm2 start pm2-brandA.json
     ```

5. **自动执行数据库迁移（Flyway）**

   * 程序启动后，Flyway 会自动执行从 v1.0.1 到 v1.2.0 之间的所有迁移脚本。
   * 同一版本下，各品牌数据库结构自然保持一致。

## 5.3 升级后的验证

1. 核心功能自测（登录、充电下单、结算、投资者报表等）。
2. 监控日志与指标，观察是否有异常。
3. 若出现严重问题：

   * 停止当前进程；
   * 回滚到旧 JAR（evcharge-v1.0.1.jar）；
   * 如有必要配合数据库回滚。

---

# 六、PM2 品牌启动模板（进程守护专用）

**PM2 的定位非常明确：只负责“守护进程”，不负责品牌逻辑、版本控制、配置选择。**

它主要用来：

* 让程序挂掉后自动重启；
* 统一管理日志；
* 支持平滑重启 / 部署。

---

## 6.1 PM2 基本使用方式

以品牌 A 为例，配置文件命名为 `pm2-brandA.json`：

```json
{
  "apps": {
    "name": "CenterApi",
    "script": "java",
    "exec_mode": "fork",
    "error_file": "../logs/CenterApi/pm2_err.log",
    "out_file": "../logs/CenterApi/pm2_out.log",
    "merge_logs": true,
    "watch": [
      "CenterApi-1.jar"
    ],
    "watch_delay": 3000,
    "min_uptime": "60s",
    "max_restarts": 30,
    "autorestart": true,
    "restart_delay": "60",
    "args": [
      "-Xms1g",
      "-Xmx2g",
      "-XX:+UseG1GC",
      "-jar",
      "CenterApi-1.jar",
      "--server.port=7091",
      "--config.type=release"
    ]
  }
}

```

品牌 B 示例：`pm2-brandB.json` 类似，只是调整 JAR 路径、配置目录、日志目录和名字。

---

## 6.2 管理命令示例

```bash
# 启动
pm2 start pm2-brandA.json
pm2 start pm2-brandB.json

# 查看状态
pm2 ls

# 查看日志
pm2 logs evcharge-brandA

# 重启
pm2 restart evcharge-brandA

# 停止
pm2 stop evcharge-brandA
```

注意：

* 不要在 PM2 里硬编码品牌逻辑，品牌隔离应通过“目录 + 配置 + JAR”来完成。
* 同一机器上多个品牌只要端口、目录、日志路径不冲突即可。

---

# 七、最终最佳实践总结（精华版）

1. **数据库版本统一由 Flyway 管理（目标状态）**

   * 避免手工 SQL；
   * 避免结构不一致、回滚困难。

2. **Git 分支用于开发管理（过程）**

   * 标准 GitFlow：`feature → develop → release → main`；
   * hotfix 专门应对线上紧急问题。

3. **Git Tag 用于正式版本管理（结果）**

   * 每个 Tag = 稳定代码 + 迁移脚本；
   * 发布时一律从 Tag 打包。

4. **不同品牌运行不同 Tag**

   * 天然支持多品牌多版本并行；
   * 不需要复制项目、不需要多仓库。

5. **一套代码 → 多版本 JAR → 多套配置目录**

   * JAR 按版本命名；
   * 每个品牌独立目录与配置；
   * 品牌之间互不影响。

6. **配置外置、文件夹隔离**

   * 配置不随着 JAR 变化；
   * 同机也可安全部署多品牌。

7. **版本升级有清晰流程**

   * 先选 Tag、再打包、再备份、再停机升级；
   * 启动后由 Flyway 自动迁移数据库；
   * 出问题有明确回滚路径。

8. **PM2 只负责进程守护**

   * 启动指定 JAR + 配置；
   * 自动重启与日志管理；
   * 不承担品牌、版本、环境的业务逻辑。
